/**
 * Annotation Converter
 * Converts between frontend (pixel coordinates) and backend (normalized 0-1) formats
 */

import type {
  Annotation,
  PolygonAnnotation,
  RectangleAnnotation,
} from '../types/annotations'
import type {
  DetectionCreate,
  DetectionResponse,
  SegmentationCreate,
  SegmentationResponse,
} from './api-client'

// ============================================================================
// ID Validation Utilities
// ============================================================================

/**
 * Check if an ID looks like a UUID (backend ID) vs a timestamp-based ID (frontend ID)
 * Backend UUIDs are in format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
 * Frontend IDs are typically timestamps or timestamp-based strings
 */
function isBackendUUID(id: string): boolean {
  // UUID v4 regex pattern
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  return uuidRegex.test(id)
}

/**
 * Get the valid frontend ID, avoiding backend UUIDs that got corrupted into the frontendId field
 * Returns the frontendId only if it's NOT a backend UUID
 */
function getValidFrontendId(frontendId: string | undefined, backendId: string): string | undefined {
  if (!frontendId) return undefined
  // If frontendId looks like a UUID (and is different from the actual backendId),
  // it's likely corrupted data from a previous buggy sync
  if (isBackendUUID(frontendId) && frontendId !== backendId) {
    console.warn('[annotation-converter] Detected corrupted frontendId (looks like UUID):', frontendId)
    return undefined
  }
  return frontendId
}

// ============================================================================
// Frontend → Backend Conversion
// ============================================================================

/**
 * Convert frontend RectangleAnnotation to backend DetectionCreate
 * Normalizes pixel coordinates to 0-1 range
 */
export function rectangleToDetection(
  rect: RectangleAnnotation,
  imageWidth: number,
  imageHeight: number
): DetectionCreate {
  // Use originalFrontendId if available, otherwise use id
  // This prevents sending corrupted (backend UUID) IDs as frontendId
  const frontendIdToSend = rect.originalFrontendId || rect.id

  // Warn if we're about to send a UUID as frontendId (indicates corruption)
  if (isBackendUUID(frontendIdToSend)) {
    console.warn('[rectangleToDetection] WARNING: frontendId looks like a UUID, may be corrupted:', frontendIdToSend)
  }

  return {
    label_id: rect.labelId,
    x_min: rect.x / imageWidth,
    y_min: rect.y / imageHeight,
    x_max: (rect.x + rect.width) / imageWidth,
    y_max: (rect.y + rect.height) / imageHeight,
    confidence: rect.confidence ?? 1.0,
    attributes: {
      isAutoGenerated: rect.isAutoGenerated ?? false,
      frontendId: frontendIdToSend,
    },
  }
}

/**
 * Convert frontend PolygonAnnotation to backend SegmentationCreate
 * Normalizes pixel coordinates to 0-1 range
 */
export function polygonToSegmentation(
  poly: PolygonAnnotation,
  imageWidth: number,
  imageHeight: number
): SegmentationCreate {
  // Use originalFrontendId if available, otherwise use id
  // This prevents sending corrupted (backend UUID) IDs as frontendId
  const frontendIdToSend = poly.originalFrontendId || poly.id

  // Warn if we're about to send a UUID as frontendId (indicates corruption)
  if (isBackendUUID(frontendIdToSend)) {
    console.warn('[polygonToSegmentation] WARNING: frontendId looks like a UUID, may be corrupted:', frontendIdToSend)
  }

  return {
    label_id: poly.labelId,
    format: 'polygon',
    polygon: poly.points.map((p) => [p.x / imageWidth, p.y / imageHeight]),
    confidence: poly.confidence ?? 1.0,
    attributes: {
      isAutoGenerated: poly.isAutoGenerated ?? false,
      frontendId: frontendIdToSend,
    },
  }
}

/**
 * Convert a frontend Annotation to the appropriate backend format
 */
export function annotationToBackend(
  annotation: Annotation,
  imageWidth: number,
  imageHeight: number
): { type: 'detection' | 'segmentation'; data: DetectionCreate | SegmentationCreate } | null {
  switch (annotation.type) {
    case 'rectangle':
      return {
        type: 'detection',
        data: rectangleToDetection(annotation as RectangleAnnotation, imageWidth, imageHeight),
      }
    case 'polygon':
      return {
        type: 'segmentation',
        data: polygonToSegmentation(annotation as PolygonAnnotation, imageWidth, imageHeight),
      }
    case 'point':
      // Points are not yet supported in backend
      console.warn('Point annotations are not yet supported for backend sync')
      return null
    default:
      return null
  }
}

// ============================================================================
// Backend → Frontend Conversion
// ============================================================================

/**
 * Convert backend DetectionResponse to frontend RectangleAnnotation
 * Converts normalized 0-1 coordinates to pixel coordinates
 */
export function detectionToRectangle(
  det: DetectionResponse,
  imageWidth: number,
  imageHeight: number
): RectangleAnnotation {
  const x = det.x_min * imageWidth
  const y = det.y_min * imageHeight
  const width = (det.x_max - det.x_min) * imageWidth
  const height = (det.y_max - det.y_min) * imageHeight

  // Get frontend ID from attributes, but validate it's not a corrupted UUID
  const rawFrontendId = det.attributes?.frontendId as string | undefined
  const validFrontendId = getValidFrontendId(rawFrontendId, det.id)

  // If frontendId was corrupted (a UUID), generate a new timestamp-based ID
  // to prevent the corruption from spreading
  const finalId = validFrontendId || `recovered-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

  if (!validFrontendId && rawFrontendId) {
    console.warn('[detectionToRectangle] Recovered from corrupted frontendId. Old:', rawFrontendId, 'New:', finalId)
  }

  return {
    id: finalId,
    imageId: det.image_id,
    labelId: det.label_id,
    type: 'rectangle',
    x,
    y,
    width,
    height,
    confidence: det.confidence ?? undefined,
    isAutoGenerated: det.attributes?.isAutoGenerated as boolean | undefined,
    isVisible: true,
    createdAt: new Date(det.created_at).getTime(),
    updatedAt: new Date(det.updated_at).getTime(),
    backendId: det.id, // Store backend ID for API operations
    originalFrontendId: validFrontendId, // Store original valid frontend ID (may be undefined if corrupted)
  }
}

/**
 * Convert backend SegmentationResponse to frontend PolygonAnnotation
 * Converts normalized 0-1 coordinates to pixel coordinates
 */
export function segmentationToPolygon(
  seg: SegmentationResponse,
  imageWidth: number,
  imageHeight: number
): PolygonAnnotation {
  const points = (seg.polygon ?? []).map(([x, y]) => ({
    x: x * imageWidth,
    y: y * imageHeight,
  }))

  // Get frontend ID from attributes, but validate it's not a corrupted UUID
  const rawFrontendId = seg.attributes?.frontendId as string | undefined
  const validFrontendId = getValidFrontendId(rawFrontendId, seg.id)

  // If frontendId was corrupted (a UUID), generate a new timestamp-based ID
  // to prevent the corruption from spreading
  const finalId = validFrontendId || `recovered-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

  if (!validFrontendId && rawFrontendId) {
    console.warn('[segmentationToPolygon] Recovered from corrupted frontendId. Old:', rawFrontendId, 'New:', finalId)
  }

  return {
    id: finalId,
    imageId: seg.image_id,
    labelId: seg.label_id,
    type: 'polygon',
    points,
    confidence: seg.confidence ?? undefined,
    isAutoGenerated: seg.attributes?.isAutoGenerated as boolean | undefined,
    isVisible: true,
    createdAt: new Date(seg.created_at).getTime(),
    updatedAt: new Date(seg.updated_at).getTime(),
    backendId: seg.id, // Store backend ID for API operations
    originalFrontendId: validFrontendId, // Store original valid frontend ID (may be undefined if corrupted)
  }
}

/**
 * Convert all backend annotations for an image to frontend format
 */
export function convertBackendAnnotations(
  detections: DetectionResponse[],
  segmentations: SegmentationResponse[],
  imageWidth: number,
  imageHeight: number
): Annotation[] {
  const rectangles = detections.map((det) =>
    detectionToRectangle(det, imageWidth, imageHeight)
  )
  const polygons = segmentations.map((seg) =>
    segmentationToPolygon(seg, imageWidth, imageHeight)
  )

  return [...rectangles, ...polygons]
}

// ============================================================================
// Batch Conversion Utilities
// ============================================================================

/**
 * Separate annotations by type for bulk backend operations
 */
export function separateAnnotationsByType(
  annotations: Annotation[],
  imageWidth: number,
  imageHeight: number
): {
  detections: DetectionCreate[]
  segmentations: SegmentationCreate[]
} {
  const detections: DetectionCreate[] = []
  const segmentations: SegmentationCreate[] = []

  for (const ann of annotations) {
    const converted = annotationToBackend(ann, imageWidth, imageHeight)
    if (converted) {
      if (converted.type === 'detection') {
        detections.push(converted.data as DetectionCreate)
      } else {
        segmentations.push(converted.data as SegmentationCreate)
      }
    }
  }

  return { detections, segmentations }
}

// ============================================================================
// ID Mapping Utilities
// ============================================================================

/**
 * Create a mapping from frontend IDs to backend IDs
 * Useful for tracking which annotations have been synced
 */
export interface AnnotationIdMap {
  frontendId: string
  backendId: string
  type: 'detection' | 'segmentation'
}

/**
 * Extract frontend ID from backend annotation attributes
 */
export function getFrontendId(
  response: DetectionResponse | SegmentationResponse
): string | undefined {
  return response.attributes?.frontendId as string | undefined
}

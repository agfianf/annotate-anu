/**
 * SVG annotation overlay for thumbnails
 * Renders bounding boxes and polygons with configurable display options
 * Supports highlight mode to dim image and spotlight annotations
 * Enhanced with source icons (manual vs AI) and confidence display
 */

import { useId } from 'react';
import type { BboxPreview, PolygonPreview } from '../../lib/data-management-client';
import type { AnnotationDisplayState, DimLevel, StrokeOpacityLevel } from '../../hooks/useExploreVisibility';
import { getTextColorForBackground } from '../../lib/colors';

// Stroke width mapping (relative to viewBox 0-1)
const STROKE_WIDTH_MAP: Record<AnnotationDisplayState['strokeWidth'], number> = {
  'thin': 0.004,
  'normal': 0.008,
  'medium': 0.012,
  'thick': 0.018,
  'extra-thick': 0.025,
};

// Fill opacity mapping
const FILL_OPACITY_MAP: Record<AnnotationDisplayState['fillOpacity'], number> = {
  'none': 0,
  'light': 0.1,
  'medium': 0.25,
  'strong': 0.4,
  'solid': 0.6,
};

// Stroke opacity mapping
const STROKE_OPACITY_MAP: Record<StrokeOpacityLevel, number> = {
  'none': 0,
  'light': 0.25,
  'medium': 0.5,
  'strong': 0.75,
  'solid': 1.0,
};

// Dim level mapping for highlight mode (image dimming opacity)
const DIM_LEVEL_MAP: Record<DimLevel, number> = {
  'subtle': 0.3,
  'medium': 0.5,
  'strong': 0.7,
};

// Star marker for AI-assisted annotations (manual shows nothing)
const AI_MARKER = 'â˜…';

interface AnnotationOverlayProps {
  /** Array of bounding boxes to render */
  bboxes?: BboxPreview[];
  /** Array of polygons to render */
  polygons?: PolygonPreview[];
  /** Display options for annotations */
  displayOptions?: AnnotationDisplayState;
  /** Whether to show only on hover */
  showOnHover?: boolean;
  /** Optional filter function to determine if an annotation should be shown */
  shouldShowAnnotation?: (labelId?: string, confidence?: number) => boolean;
}

/**
 * Convert polygon points to SVG path string
 */
function pointsToPath(points: [number, number][]): string {
  if (!points || points.length === 0) return '';
  const [first, ...rest] = points;
  return `M ${first[0]},${first[1]} ` +
         rest.map((p) => `L ${p[0]},${p[1]}`).join(' ') +
         ' Z';
}

/**
 * Calculate centroid of a polygon for label positioning
 */
function getCentroid(points: [number, number][]): [number, number] {
  if (!points || points.length === 0) return [0, 0];
  const n = points.length;
  const x = points.reduce((sum, p) => sum + p[0], 0) / n;
  const y = points.reduce((sum, p) => sum + p[1], 0) / n;
  return [x, y];
}

/**
 * Get label position for a bbox (top-left corner, inside bbox)
 */
function getBboxLabelPosition(bbox: BboxPreview): [number, number] {
  return [
    bbox.x_min,  // Left edge of bbox
    bbox.y_min,  // Top edge of bbox
  ];
}

const defaultDisplayOptions: AnnotationDisplayState = {
  strokeWidth: 'normal',
  strokeOpacity: 'solid',
  showLabels: false,
  showConfidence: false,
  showBboxes: true,
  showPolygons: true,
  fillOpacity: 'none',
  highlightMode: false,
  dimLevel: 'medium',
};

// Font styling for annotation labels - compact top-left positioning
const LABEL_FONT_FAMILY = "'Source Sans 3', 'Source Sans Pro', sans-serif";
const LABEL_FONT_SIZE = 0.018;  // Slightly larger for readability
const LABEL_FONT_WEIGHT = '600';
const LABEL_PADDING_X = 0.006;  // Horizontal padding
const LABEL_PADDING_Y = 0.004;  // Vertical padding
const LABEL_CHAR_WIDTH = 0.008; // Approximate width per character

/**
 * Derive isAutoGenerated from source field
 * source starting with 'model:' indicates AI-assisted annotation
 */
function isAutoGenerated(source?: string): boolean {
  return source?.startsWith('model:') ?? false;
}

export function AnnotationOverlay({
  bboxes,
  polygons,
  displayOptions = defaultDisplayOptions,
  showOnHover = true,
  shouldShowAnnotation,
}: AnnotationOverlayProps) {
  // Generate unique ID for mask to avoid conflicts with multiple overlays
  const maskId = useId();

  // Filter annotations if filter function provided
  const filteredBboxes = shouldShowAnnotation
    ? bboxes?.filter((bbox) => shouldShowAnnotation(bbox.label_id, bbox.confidence))
    : bboxes;
  const filteredPolygons = shouldShowAnnotation
    ? polygons?.filter((poly) => shouldShowAnnotation(poly.label_id, poly.confidence))
    : polygons;

  const showBboxes = displayOptions.showBboxes && filteredBboxes && filteredBboxes.length > 0;
  const showPolygons = displayOptions.showPolygons && filteredPolygons && filteredPolygons.length > 0;
  const highlightMode = displayOptions.highlightMode ?? false;

  // Return null only if no annotations AND highlight mode is off
  // (highlight mode should dim all images even without annotations)
  if (!showBboxes && !showPolygons && !highlightMode) return null;

  const strokeWidth = STROKE_WIDTH_MAP[displayOptions.strokeWidth];
  const strokeOpacity = STROKE_OPACITY_MAP[displayOptions.strokeOpacity ?? 'solid'];
  const fillOpacity = FILL_OPACITY_MAP[displayOptions.fillOpacity];
  const showLabels = displayOptions.showLabels;
  const showConfidence = displayOptions.showConfidence;
  const dimLevel = DIM_LEVEL_MAP[displayOptions.dimLevel ?? 'medium'];

  return (
    <svg
      className={`absolute inset-0 pointer-events-none transition-opacity duration-200 ${
        showOnHover ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'
      }`}
      viewBox="0 0 1 1"
      preserveAspectRatio="none"
      style={{ width: '100%', height: '100%' }}
    >
      {/* Highlight mode: dim overlay with annotation cutouts */}
      {highlightMode && (
        <>
          <defs>
            <mask id={maskId}>
              {/* White background = fully visible (dimmed area) */}
              <rect x="0" y="0" width="1" height="1" fill="white" />

              {/* Black cutouts for bboxes = fully transparent (spotlight) */}
              {showBboxes && filteredBboxes?.map((bbox, idx) => (
                <rect
                  key={`mask-bbox-${idx}`}
                  x={bbox.x_min}
                  y={bbox.y_min}
                  width={bbox.x_max - bbox.x_min}
                  height={bbox.y_max - bbox.y_min}
                  fill="black"
                />
              ))}

              {/* Black cutouts for polygons = fully transparent (spotlight) */}
              {showPolygons && filteredPolygons?.map((poly, idx) => {
                const pathD = pointsToPath(poly.points);
                if (!pathD) return null;
                return (
                  <path
                    key={`mask-poly-${idx}`}
                    d={pathD}
                    fill="black"
                  />
                );
              })}
            </mask>
          </defs>

          {/* Dark overlay with mask (annotation areas are cut out) */}
          <rect
            x="0"
            y="0"
            width="1"
            height="1"
            fill="black"
            fillOpacity={dimLevel}
            mask={`url(#${maskId})`}
          />
        </>
      )}

      {/* Render bboxes (detections) */}
      {showBboxes && filteredBboxes?.map((bbox, idx) => {
        const labelPos = getBboxLabelPosition(bbox);
        const isAuto = isAutoGenerated(bbox.source);
        // Only show star marker for AI-assisted annotations, nothing for manual
        const sourceMarker = isAuto ? ` ${AI_MARKER}` : '';
        const confidenceText = showConfidence && bbox.confidence != null
          ? ` ${Math.round(bbox.confidence * 100)}%`
          : '';
        const labelText = `${bbox.label_name}${sourceMarker}${confidenceText}`;
        const textColor = getTextColorForBackground(bbox.label_color);

        return (
          <g key={`bbox-${idx}`}>
            <rect
              x={bbox.x_min}
              y={bbox.y_min}
              width={bbox.x_max - bbox.x_min}
              height={bbox.y_max - bbox.y_min}
              fill={bbox.label_color}
              fillOpacity={fillOpacity}
              stroke={bbox.label_color}
              strokeWidth={strokeWidth}
              strokeOpacity={strokeOpacity}
            />
            {showLabels && bbox.label_name && (() => {
              // Calculate dynamic width based on text length
              const textWidth = labelText.length * LABEL_CHAR_WIDTH + LABEL_PADDING_X * 2;
              const textHeight = LABEL_FONT_SIZE + LABEL_PADDING_Y * 2;
              return (
                <g>
                  {/* Background rect for label - positioned at top-left corner */}
                  <rect
                    x={labelPos[0]}
                    y={labelPos[1]}
                    width={textWidth}
                    height={textHeight}
                    fill={bbox.label_color}
                    fillOpacity={0.95}
                  />
                  {/* Label text - left aligned */}
                  <text
                    x={labelPos[0] + LABEL_PADDING_X}
                    y={labelPos[1] + textHeight / 2}
                    fill={textColor}
                    fontFamily={LABEL_FONT_FAMILY}
                    fontSize={LABEL_FONT_SIZE}
                    fontWeight={LABEL_FONT_WEIGHT}
                    textAnchor="start"
                    dominantBaseline="middle"
                  >
                    {labelText}
                  </text>
                </g>
              );
            })()}
          </g>
        );
      })}

      {/* Render polygons (segmentations) */}
      {showPolygons && filteredPolygons?.map((poly, idx) => {
        const centroid = getCentroid(poly.points);
        const pathD = pointsToPath(poly.points);
        if (!pathD) return null;

        const isAuto = isAutoGenerated(poly.source);
        // Only show star marker for AI-assisted annotations, nothing for manual
        const sourceMarker = isAuto ? ` ${AI_MARKER}` : '';
        const confidenceText = showConfidence && poly.confidence != null
          ? ` ${Math.round(poly.confidence * 100)}%`
          : '';
        const labelText = `${poly.label_name}${sourceMarker}${confidenceText}`;
        const textColor = getTextColorForBackground(poly.label_color);

        return (
          <g key={`poly-${idx}`}>
            <path
              d={pathD}
              fill={poly.label_color}
              fillOpacity={fillOpacity}
              stroke={poly.label_color}
              strokeWidth={strokeWidth}
              strokeOpacity={strokeOpacity}
              strokeLinejoin="round"
            />
            {showLabels && poly.label_name && (() => {
              // Calculate dynamic width based on text length
              const textWidth = labelText.length * LABEL_CHAR_WIDTH + LABEL_PADDING_X * 2;
              const textHeight = LABEL_FONT_SIZE + LABEL_PADDING_Y * 2;
              return (
                <g>
                  {/* Background rect for label - centered on polygon */}
                  <rect
                    x={centroid[0] - textWidth / 2}
                    y={centroid[1] - textHeight / 2}
                    width={textWidth}
                    height={textHeight}
                    fill={poly.label_color}
                    fillOpacity={0.95}
                  />
                  {/* Label text - centered */}
                  <text
                    x={centroid[0]}
                    y={centroid[1]}
                    fill={textColor}
                    fontFamily={LABEL_FONT_FAMILY}
                    fontSize={LABEL_FONT_SIZE}
                    fontWeight={LABEL_FONT_WEIGHT}
                    textAnchor="middle"
                    dominantBaseline="middle"
                  >
                    {labelText}
                  </text>
                </g>
              );
            })()}
          </g>
        );
      })}
    </svg>
  );
}

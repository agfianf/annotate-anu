# Annotation Sync Architecture & Duplicate Bug Fix

**Audience**: AI Engineers, Backend Engineers, Frontend Engineers
**Last Updated**: December 2025

## Table of Contents
- [Overview](#overview)
- [System Architecture](#system-architecture)
- [The Duplicate Annotation Bug](#the-duplicate-annotation-bug)
- [Root Cause Analysis](#root-cause-analysis)
- [The Fix](#the-fix)
- [Prevention Guidelines](#prevention-guidelines)
- [API Reference](#api-reference)

---

## Overview

This document explains the architecture of annotation synchronization between frontend and backend in Team Mode, details a critical race condition bug that caused duplicate annotations, and documents the fix.

### Key Concepts

**Frontend ID (`frontendId`)**: Timestamp-based unique identifier generated on the frontend when an annotation is created locally (e.g., `"1765635225344"`).

**Backend ID (`backendId`)**: UUID generated by PostgreSQL when the annotation is persisted to the database (e.g., `"a1b2c3d4-e5f6-..."`).

**Synced Annotations Map**: A `Map<string, string>` that tracks the relationship: `frontendId → backendId` for annotations that have been synced to the backend.

---

## System Architecture

### Data Flow in Team Mode

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. USER CREATES ANNOTATION                                          │
│    Canvas → useJobStorage.jobAddAnnotation()                        │
│    - Generates frontendId: "1765635225344"                          │
│    - Stores in local state + IndexedDB                              │
│    - Calls autoSave.markCreate()                                    │
└─────────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 2. AUTO-SAVE SYNC (every 5 seconds)                                 │
│    useAutoSave.syncToBackend()                                      │
│    - Converts to backend format (normalized coordinates)            │
│    - Sends: { detections: { created: [{ ..., attributes: {         │
│                frontendId: "1765635225344" } }] } }                 │
└─────────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 3. BACKEND CREATES ANNOTATION                                       │
│    POST /api/v1/jobs/{jobId}/annotations/sync                       │
│    - Creates detection in PostgreSQL                                │
│    - Generates UUID: "a1b2c3d4-..."                                 │
│    - Stores frontendId in JSONB attributes field:                   │
│      { "frontendId": "1765635225344", "isAutoGenerated": false }    │
└─────────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 4. SYNC SUCCESS CALLBACK                                            │
│    onSyncSuccess() → loadJobAnnotations()                           │
│    - Fetches all annotations from backend                           │
│    - Builds syncedAnnotations Map:                                  │
│      { "1765635225344" → "a1b2c3d4-..." }                           │
│    - Updates jobAnnotations state with backendId field              │
└─────────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 5. USER EDITS ANNOTATION                                            │
│    Canvas → useJobStorage.jobUpdateAnnotation()                     │
│    - Looks up backendId: annotation.backendId || syncedMap.get(id)  │
│    - If found → autoSave.markUpdate(backendId)                      │
│    - If NOT found → autoSave.markCreate() ⚠️ BUG TRIGGER            │
└─────────────────────────────────────────────────────────────────────┘
```

### State Management Flow

**Frontend State** (`useJobStorage.ts`):
```typescript
// Map tracking synced annotations
const [syncedAnnotations, setSyncedAnnotations] =
  useState<Map<string, string>>(new Map())

// All annotations for current job
const [jobAnnotations, setJobAnnotations] =
  useState<Annotation[]>([])
```

**Auto-Save Pending Changes** (`useAutoSave.ts`):
```typescript
// Pending changes waiting to sync
const pendingChangesRef = useRef<Map<string, PendingChange>>(new Map())
// Structure: annotationId → { operation: 'create' | 'update' | 'delete', ... }
```

---

## The Duplicate Annotation Bug

### Symptoms

When a user performed these steps:
1. Created an annotation (rectangle/polygon)
2. Waited for sync to complete successfully
3. **Immediately** edited the annotation (moved, resized, dragged)
4. Navigated away from the annotation page
5. Returned to the annotation page

**Result**: Two identical annotations appeared on the canvas (duplicates).

### What Was Happening in the Database

```sql
-- After first sync
SELECT id, attributes->>'frontendId' as frontend_id, updated_at
FROM detections
WHERE image_id = 'img-123';

┌──────────────┬──────────────────┬─────────────────────────┐
│      id      │   frontend_id    │       updated_at        │
├──────────────┼──────────────────┼─────────────────────────┤
│ a1b2c3d4-... │ "1765635225344"  │ 2025-12-14 10:00:00     │
└──────────────┴──────────────────┴─────────────────────────┘

-- After edit + sync (BUG: created SECOND annotation instead of update)
SELECT id, attributes->>'frontendId' as frontend_id, updated_at
FROM detections
WHERE image_id = 'img-123';

┌──────────────┬──────────────────┬─────────────────────────┐
│      id      │   frontend_id    │       updated_at        │
├──────────────┼──────────────────┼─────────────────────────┤
│ a1b2c3d4-... │ "1765635225344"  │ 2025-12-14 10:00:00     │ ← OLD
│ e7f8g9h0-... │ "1765635225344"  │ 2025-12-14 10:00:05     │ ← DUPLICATE!
└──────────────┴──────────────────┴─────────────────────────┘
```

**Critical Issue**: Both annotations have the **same** `frontendId`, causing duplicate rendering on the frontend.

### Console Logs (Buggy Behavior)

```javascript
// Step 1: Sync completes
[loadJobAnnotations] Fetched detections: [
  { backendId: "a1b2c3d4-...", frontendId: "1765635225344" }
]
[loadJobAnnotations] syncedAnnotations Map: [["1765635225344", "a1b2c3d4-..."]]

// Step 2: User edits annotation IMMEDIATELY
[jobUpdateAnnotation] Called with: { id: "1765635225344", backendId: undefined }
[jobUpdateAnnotation] syncedAnnotations.get(id): undefined  ⚠️ STALE CLOSURE!
[jobUpdateAnnotation] Resolved backendId: undefined
[jobUpdateAnnotation] Operation: CREATE (POTENTIAL BUG!)

// Step 3: Sync sends CREATE instead of UPDATE
[syncToBackend] Payload: {
  "img-123": {
    "detections": {
      "created": [{  ⚠️ SHOULD BE "updated"!
        "label_id": "...",
        "x_min": 0.2,
        "attributes": { "frontendId": "1765635225344" }
      }]
    }
  }
}

// Step 4: Backend creates DUPLICATE annotation
// Database now has 2 annotations with frontendId "1765635225344"
```

---

## Root Cause Analysis

### The Race Condition

The bug was caused by a **React closure stale state issue**:

```typescript
// ❌ BUGGY CODE (before fix)
const [syncedAnnotations, setSyncedAnnotations] = useState(new Map())

const jobUpdateAnnotation = useCallback(
  async (annotation: Annotation) => {
    // This closure captures syncedAnnotations at callback creation time
    const backendId = annotation.backendId || syncedAnnotations.get(annotation.id)
    //                                        ^^^^^^^^^^^^^^^^^^^
    //                                        May be STALE if setSyncedAnnotations
    //                                        was called but React hasn't re-rendered

    if (backendId) {
      autoSave.markUpdate(annotation, backendId, ...)  // ✅ UPDATE
    } else {
      autoSave.markCreate(annotation, ...)  // ❌ CREATE (creates duplicate!)
    }
  },
  [syncedAnnotations, autoSave]  // Callback recreated when syncedAnnotations changes
)
```

**Timeline of the Bug**:
```
t=0ms:    User creates annotation (frontendId: "1765635225344")
t=5000ms: Auto-save syncs → backend creates (backendId: "a1b2c3d4-...")
t=5050ms: onSyncSuccess() calls loadJobAnnotations()
t=5100ms: setSyncedAnnotations({ "1765635225344" → "a1b2c3d4-..." })
t=5150ms: React schedules re-render (but hasn't executed yet)
t=5160ms: ⚠️ User drags annotation (triggers jobUpdateAnnotation)
          → Callback still has OLD empty Map in closure
          → syncedAnnotations.get("1765635225344") returns undefined
          → Falls back to markCreate()
t=5200ms: React re-renders with new syncedAnnotations (too late!)
t=10000ms: Auto-save syncs again → sends CREATE instead of UPDATE
          → Backend creates SECOND annotation with same frontendId
```

### Why React Closures Are Stale

React's `useCallback` captures variables from the surrounding scope **at the time the callback is created**. When you update state with `setSyncedAnnotations`, React schedules a re-render, but:

1. The re-render is **asynchronous** (not immediate)
2. Any callbacks invoked **before** the re-render still have the **old** values in their closure
3. The `jobUpdateAnnotation` callback won't get the new Map until React re-renders and recreates the callback

### Additional Contributing Factors

**Frontend ID Corruption**:
- In some cases, backend UUIDs were incorrectly used as `frontendId` values
- This created ID corruption chains where annotations lost their original frontend IDs
- Fixed by adding `originalFrontendId` field and UUID validation

**Deduplication Missing on Load**:
- Multiple backend annotations with same `frontendId` were all loaded without deduplication
- Frontend rendered all of them, showing duplicates
- Fixed by deduplicating by `frontendId` during load, keeping the latest by `updated_at`

---

## The Fix

### Solution 1: Ref Pattern for Synchronous Access

Use `useRef` to maintain a reference to the latest `syncedAnnotations` Map:

```typescript
// ✅ FIXED CODE
const [syncedAnnotations, setSyncedAnnotations] = useState(new Map())

// Add a ref that always contains the latest value
const syncedAnnotationsRef = useRef(syncedAnnotations)
useEffect(() => {
  syncedAnnotationsRef.current = syncedAnnotations
}, [syncedAnnotations])

const jobUpdateAnnotation = useCallback(
  async (annotation: Annotation) => {
    // Use .current to get the LATEST value synchronously
    const backendId = annotation.backendId || syncedAnnotationsRef.current.get(annotation.id)
    //                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
    //                                        Always up-to-date, no stale closure!

    if (backendId) {
      autoSave.markUpdate(annotation, backendId, ...)  // ✅ Correct UPDATE
    } else {
      autoSave.markCreate(annotation, ...)
    }
  },
  [autoSave]  // No longer depends on syncedAnnotations state
)
```

**Key Benefits**:
- `syncedAnnotationsRef.current` is **always** the latest value
- No stale closures - reads happen synchronously
- Callback doesn't need to be recreated when Map updates (fewer re-renders)

**Files Changed**:
- `apps/web/src/hooks/useJobStorage.ts`:
  - Line 155-158: Added ref and effect
  - Line 396: `jobUpdateAnnotation` uses ref
  - Line 434: `jobUpdateManyAnnotations` uses ref
  - Line 463: `jobRemoveAnnotation` uses ref
  - Line 489: `jobRemoveManyAnnotations` uses ref

### Solution 2: Deduplication on Load

Prevent duplicate annotations from appearing on the UI:

```typescript
const loadJobAnnotations = useCallback(async () => {
  // Collect ALL raw annotations from all images
  const allRawAnnotations: RawAnnotation[] = []

  for (const img of jobContext.images) {
    const response = await annotationsApi.getForImage(img.id)
    for (const det of response.detections) {
      allRawAnnotations.push({ type: 'detection', data: det, ... })
    }
    // ... same for segmentations
  }

  // Deduplicate: keep the LATEST annotation for each frontendId
  const dedupedByFrontendId = new Map<string, RawAnnotation>()

  for (const rawAnn of allRawAnnotations) {
    const frontendId = rawAnn.data.attributes?.frontendId
    if (!frontendId) continue

    const existing = dedupedByFrontendId.get(frontendId)
    if (existing) {
      // Compare updated_at timestamps, keep newer
      const existingTime = new Date(existing.data.updated_at).getTime()
      const newTime = new Date(rawAnn.data.updated_at).getTime()

      if (newTime > existingTime) {
        dedupedByFrontendId.set(frontendId, rawAnn)  // Keep newer
        console.warn('[loadJobAnnotations] DUPLICATE - keeping newer:', frontendId)
      } else {
        // Keep existing (newer or same), drop this one
        console.warn('[loadJobAnnotations] DUPLICATE - dropping older:', frontendId)
      }
    } else {
      dedupedByFrontendId.set(frontendId, rawAnn)  // First occurrence
    }
  }

  // Convert only deduplicated annotations
  const allAnnotations = []
  for (const [frontendId, rawAnn] of dedupedByFrontendId) {
    const converted = convertBackendAnnotations([rawAnn.data], ...)
    allAnnotations.push(...converted)
  }

  console.log('[loadJobAnnotations] Dropped',
    allRawAnnotations.length - allAnnotations.length, 'duplicates')

  setJobAnnotations(allAnnotations)
}, [jobContext.images])
```

**Key Benefits**:
- Handles **existing** duplicates in the database gracefully
- User sees only the latest version of each annotation
- Logs how many duplicates were found and dropped

**Files Changed**:
- `apps/web/src/hooks/useJobStorage.ts`: Lines 200-277

### Solution 3: Frontend ID Validation

Prevent UUID corruption:

```typescript
// annotation-converter.ts

function isBackendUUID(id: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  return uuidRegex.test(id)
}

function getValidFrontendId(frontendId: string | undefined, backendId: string): string | undefined {
  if (!frontendId) return undefined

  // If frontendId looks like a UUID (corrupted data), reject it
  if (isBackendUUID(frontendId) && frontendId !== backendId) {
    console.warn('[annotation-converter] Detected corrupted frontendId (UUID):', frontendId)
    return undefined
  }

  return frontendId
}

export function detectionToRectangle(det: DetectionResponse, ...): RectangleAnnotation {
  const rawFrontendId = det.attributes?.frontendId as string | undefined
  const validFrontendId = getValidFrontendId(rawFrontendId, det.id)

  // If corrupted, generate a recovery ID
  const finalId = validFrontendId || `recovered-${Date.now()}-${Math.random()...}`

  return {
    id: finalId,
    backendId: det.id,
    originalFrontendId: validFrontendId,  // Store original (may be undefined if corrupted)
    // ...
  }
}
```

**Files Changed**:
- `apps/web/src/lib/annotation-converter.ts`: Lines 22-46, 150-189
- `apps/web/src/types/annotations.ts`: Line 44 (added `originalFrontendId` field)

---

## Prevention Guidelines

### For Frontend Engineers

#### 1. Use Refs for Values That Need Synchronous Access

**When to use refs**:
- Values accessed in callbacks that need to be **always up-to-date**
- Derived state that changes frequently but doesn't need to trigger re-renders
- Values shared across callbacks but don't affect rendering

**Pattern**:
```typescript
const [value, setValue] = useState(initialValue)
const valueRef = useRef(value)

useEffect(() => {
  valueRef.current = value
}, [value])

const callback = useCallback(() => {
  // Use valueRef.current for latest value
  const latest = valueRef.current
}, [])  // No dependency on 'value' - won't recreate on every change
```

#### 2. Be Careful with Closure Dependencies

**Bad** - Stale closure:
```typescript
const [count, setCount] = useState(0)

const handleClick = useCallback(() => {
  console.log(count)  // May be stale!
}, [])  // Missing 'count' in dependencies
```

**Good** - Use functional update:
```typescript
const [count, setCount] = useState(0)

const handleClick = useCallback(() => {
  setCount(prev => {
    console.log(prev)  // Always latest
    return prev + 1
  })
}, [])
```

**Good** - Use ref for reading:
```typescript
const [count, setCount] = useState(0)
const countRef = useRef(count)
useEffect(() => { countRef.current = count }, [count])

const handleClick = useCallback(() => {
  console.log(countRef.current)  // Always latest
}, [])
```

#### 3. Log State for Debugging

Always add strategic logging for complex state flows:

```typescript
console.log('[functionName] Input:', { param1, param2 })
console.log('[functionName] State before:', state)
console.log('[functionName] Computed value:', derived)
console.log('[functionName] Operation:', operation ? 'UPDATE' : 'CREATE')
```

This helped us identify the stale closure issue immediately!

#### 4. Deduplicate on Load When Using External IDs

If your system uses both client-side IDs and server-side IDs:
- Always deduplicate by client ID when loading from server
- Keep the latest version (by timestamp)
- Log discarded duplicates for monitoring

### For Backend Engineers

#### 1. Upsert Logic for External ID Systems

If your API accepts a client-generated ID (like `frontendId`), implement upsert logic:

```python
async def sync_annotations(job_id: int, data: AnnotationSyncRequest):
    for item in data.detections.created:
        frontend_id = item.attributes.get('frontendId')

        if frontend_id:
            # Check if annotation with this frontendId already exists
            existing = await DetectionRepository.find_by_frontend_id(
                connection, image_id, frontend_id
            )

            if existing:
                # Update existing instead of creating duplicate
                await DetectionRepository.update(
                    connection, existing['id'], item
                )
                logger.warning(f"Prevented duplicate: frontendId={frontend_id}")
            else:
                # Create new
                await DetectionRepository.create(connection, image_id, item)
        else:
            # No frontendId, create as usual
            await DetectionRepository.create(connection, image_id, item)
```

**Benefits**:
- Idempotent API - safe to retry
- Prevents duplicates even if frontend sends CREATE twice
- **Belt and suspenders** approach

#### 2. Add Database Constraints

Prevent duplicates at the database level:

```sql
-- Option 1: Unique constraint on frontendId (if always present)
ALTER TABLE detections
ADD CONSTRAINT unique_frontend_id_per_image
UNIQUE (image_id, (attributes->>'frontendId'));

-- Option 2: Partial unique index (if frontendId is optional)
CREATE UNIQUE INDEX idx_detections_frontend_id
ON detections (image_id, (attributes->>'frontendId'))
WHERE attributes->>'frontendId' IS NOT NULL;
```

**Benefits**:
- Database enforces uniqueness
- API will get a constraint violation error instead of silently creating duplicates
- Can handle with `ON CONFLICT` in PostgreSQL

#### 3. Validate Request Payload

```python
from pydantic import BaseModel, field_validator

class DetectionCreate(BaseModel):
    label_id: str
    x_min: float
    attributes: dict

    @field_validator('attributes')
    def validate_frontend_id(cls, v):
        if 'frontendId' in v:
            frontend_id = v['frontendId']
            # Validate it's not a UUID (should be timestamp or client-generated)
            if re.match(r'^[0-9a-f]{8}-[0-9a-f]{4}-', frontend_id):
                raise ValueError(f"frontendId should not be a UUID: {frontend_id}")
        return v
```

#### 4. Add Monitoring and Alerts

```python
# Log when duplicates are detected
if existing:
    logger.warning(
        f"Duplicate frontendId detected",
        extra={
            'job_id': job_id,
            'image_id': image_id,
            'frontend_id': frontend_id,
            'existing_backend_id': existing['id'],
            'operation': 'prevented_duplicate'
        }
    )

    # Increment metrics for monitoring
    metrics.increment('annotation_sync.duplicate_prevented')
```

Set up alerts when duplicate rate is high (indicates frontend bug).

---

## API Reference

### Frontend → Backend Sync Payload

**Endpoint**: `POST /api/v1/jobs/{jobId}/annotations/sync`

**Request Body**:
```json
{
  "images": {
    "image-id-123": {
      "detections": {
        "created": [
          {
            "label_id": "label-1",
            "x_min": 0.2,
            "y_min": 0.3,
            "x_max": 0.5,
            "y_max": 0.7,
            "confidence": 1.0,
            "attributes": {
              "frontendId": "1765635225344",
              "isAutoGenerated": false
            }
          }
        ],
        "updated": [
          {
            "id": "a1b2c3d4-e5f6-...",  // backendId
            "label_id": "label-1",
            "x_min": 0.25,
            "y_min": 0.35,
            "x_max": 0.55,
            "y_max": 0.75,
            "attributes": {
              "frontendId": "1765635225344",
              "isAutoGenerated": false
            }
          }
        ],
        "deleted": ["backend-id-to-delete"]
      },
      "segmentations": { /* same structure */ }
    }
  }
}
```

**Key Points**:
- Coordinates are **normalized** to 0-1 range
- `frontendId` is stored in `attributes` JSONB field
- `updated` items include `id` (backendId), `created` items don't

### Backend → Frontend Response

**Endpoint**: `GET /api/v1/jobs/{jobId}/images/{imageId}/annotations`

**Response**:
```json
{
  "detections": [
    {
      "id": "a1b2c3d4-e5f6-...",  // backendId (UUID)
      "image_id": "image-id-123",
      "label_id": "label-1",
      "x_min": 0.2,
      "y_min": 0.3,
      "x_max": 0.5,
      "y_max": 0.7,
      "confidence": 1.0,
      "attributes": {
        "frontendId": "1765635225344",
        "isAutoGenerated": false
      },
      "created_at": "2025-12-14T10:00:00Z",
      "updated_at": "2025-12-14T10:05:00Z"
    }
  ],
  "segmentations": [ /* same structure */ ]
}
```

**Key Points**:
- Frontend extracts `frontendId` from `attributes`
- Uses `id` as `backendId` for future updates
- Uses `updated_at` for deduplication (latest wins)

---

## Summary

### The Bug
Race condition where React state updates were asynchronous, causing `jobUpdateAnnotation` to use a stale `syncedAnnotations` Map, resulting in UPDATE operations being sent as CREATE and creating duplicate annotations in the database.

### The Fix
1. **Ref Pattern**: Use `useRef` + `useEffect` to maintain synchronous access to latest `syncedAnnotations` Map
2. **Deduplication**: Deduplicate annotations by `frontendId` on load, keeping latest by `updated_at`
3. **Validation**: Detect and recover from UUID corruption in `frontendId` field

### Key Takeaways
- React closures can be stale - use refs for synchronous access to frequently-updated state
- External ID systems need deduplication logic on both client and server
- Strategic logging is crucial for debugging async state issues
- Belt-and-suspenders: fix on frontend + add backend validation

### Files Modified
- `apps/web/src/hooks/useJobStorage.ts` - Ref pattern + deduplication
- `apps/web/src/lib/annotation-converter.ts` - UUID validation
- `apps/web/src/types/annotations.ts` - Added `originalFrontendId` field
- `apps/web/src/hooks/useAutoSave.ts` - Enhanced logging

---

**Document Version**: 1.0
**Authors**: Development Team
**Related Issues**: Duplicate Annotation Bug (December 2025)
